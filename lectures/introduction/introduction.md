---
author: Igor Fedorov
title: Agda Introduction
date: January 28, 2018
---
# Что такое Agda?

Agda — чистый функциональный язык программирования с зависимыми типами. Теоретической основой Agda служит интуиционистская теория типов Мартин-Лёфа, которая расширена набором конструкций, полезных для практического программирования.

# Почему Agda?

* Реализиует исчисление конструкций
* Гарантирует завершаемость программ
* Вместе с Coq является языком формализации HoTT
* Выглядит более человечно, чем Coq (синтаксис Agda очень похож на Haskell)
* Одновременно прогрессивный и стабильный язык

# Установка

Если у вас уже стоит Stack, то установить Agda можно командой
```shell
stack install Agda
```
Иначе установите сначала Stack

# Настройка

Для написания программ рекомендуется использовать либо Emacs, либо Atom. Я остановлюсь на последнем.
Для удобной работы нужно поставить плагины _agda-mode_ и _language-agda_, сделать это можно командами
```shell
apm install language-agda
apm install agda-mode
```

# Hello???

Наверное вы бы хотели увидеть здесь небольшую программу выводящую в консоль _Hello, World!_, но увы, а на самом деле к счастью, её здесь не будет. Вместо этого мы реализуем множество натуральных чисел в аксиоматике Пеано.

# Hello, Peano!

Agda не загружает автоматически стандартную библиотеку. Поэтому мы можем начать с нуля и не бояться коллизий.

Для начала создадим файл _Nat.agda_ и создадим в нём модуль
```agda
module Nat where
```
(в отличии от Haskell указанение модуля обязательно)

# ℕ

Определение натуральных чисел на Agda с помощью структурной индукции будет выглядеть так:
```agda
data ℕ : Set where
    zero : ℕ
    suc : ℕ → ℕ
```
(Agda поддерживает юникодные символы. С помощью ранее установленного плагина можно напечатать символы ℕ и → с помощью команд `\bN` и `\->` соответственно)

# Типы у типов

В определении натуральных чисел у нас было указано `ℕ : Set`, что в точности означает _ℕ имеет тип Set_.

Т.к. в Agda есть зависимые типы она не различает термы и типы, поэтому у каждого типа есть тип.

Какой же тип имеет Set?

# Парадокс Рассела

Для того, чтобы избежать парадокса Рассела, тип Set имеет тип не Set, а Set₁, который в свою очередь имеет тип Set₂ и т.д. Бесконечная иерархия типов позволяет избежать ситуации в которой в типе содержится он сам.

# Сложение

Давайте определим сигнатуру функции сложения
```agda
_+_ : ℕ → ℕ → ℕ
```
(В отличии от Haskell указание сигнатуры функций обязательно)

# Миксфиксы

Agda поддерживает т.н. миксфиксную запись т.е. подставлять аргументы можно прямо в название функции на место "дырок". Например, метод с сигнатурой
```agda
if_then_else_ : ∀ { a } → Bool → a → a → a
```
можно вызвать и как `if a then b else c`, и как `if_then_else_ a b c`

# Сложение

Вместе с реализацией функция сложения будет выглядеть:

```agda
_+_ : ℕ → ℕ → ℕ
zero + m = m
(suc n) + m = suc (n + m)
```

# Итог

Финальный листинг модуля выглядит так:

```agda
module Nat where

data ℕ : Set where
    zero : ℕ
    suc : ℕ → ℕ

_+_ : ℕ → ℕ → ℕ
zero + m = m
(suc n) + m = suc (n + m)
```

# TO BE CONTINUED...
