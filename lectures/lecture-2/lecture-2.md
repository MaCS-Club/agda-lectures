---
author: Igor Fedorov
title: Зависимые типы - Векторы
date: June 17 2018
---

## Nat
Вспомним определение натуральных чисел:
```agda
data ℕ : Set where
    zero : ℕ
    suc : ℕ → ℕ
{-# BUILTIN NATURAL ℕ #-}
```

## Индуктивные типы

* Основной способ для создания новых типов в функциональных языках программирования
* Описывает как можно построить терм на основе перечня конструкторов
* Например, список это сумма:
  * Пустой список
  * Первый элемент и  хвост списка

## Списки
Список в Agda можно определить так:
```agda
infixr 4 _::_

data List(A : Set) : Set where
  [] : List A
  _::_ : A → List A → List A
```

## Списки
```agda
empty : List ℕ
empty = []

upto3 : List ℕ
upto3 = 0 :: 1 :: 2 :: 3 :: []
```

## Сопоставление с образцом

Вы можете работать с индуктивными типами с помощью сопоставления с образцом. Анализируя по сути дела внешний конструктор аргумента.

Например, мы можем определить функцию *append* сопоставляя с образцом первый аргумент:

```agda
append : ∀ {A} → List A → List A → List A
append [] ys = ys
append (x :: xs) ys = x :: append xs ys
```

## Получение головы списка

Попробуем написать функцию возвращающую голову списка:

```agda
first : ∀ {A} → List A → A
first xs = ?
```

## Получение головы списка

Попробуем написать функцию возвращающую голову списка:

```agda
first : ∀ {A} → List A → A
first [] = ?
first (x :: _) = ?
```

## Получение головы списка

Попробуем написать функцию возвращающую голову списка:

```agda
first : ∀ {A} → List A → A
first [] = ?
first (x :: _) = x
```

## Получение головы списка

Попробуем написать функцию возвращающую голову списка:

```agda
data Option(A : Set) : Set where
  Some : A → Option A
  None : Option A

first : ∀ {A} → List A → Option A
first [] = None
first (x :: _) = Some x
```

## Проблема

Но иногда система типов может нам мешать:

```agda
...
let queue = upto3 in
let min = first queue in
let x = min + 5 in
...
```

## Зависимые типы

* Типы зависящие от значения
* Помогают проверять более жесткие ограничения во время компиляции
* Например: список длинны n

## Зависимые типы - Векторы

Вспомним определние списка:

```agda
data List(A : Set) : Set where
[] : List A
_::_ : A → List A → List A
```

## Зависимые типы - Векторы

Вспомним определние списка:

```agda
data List(A : Set) : Set where
[] : List A
_::_ : A → List A → List A
```

Мы можем определить список длинны *n* так:

```agda
data Vec(A : Set) : ℕ → Set where
  [] : Vec A 0
  _::_ : ∀ {n} → A → Vec A n → Vec A (1 + n)
```

## Векторы

Примеры можно оставить фактически без изменений:
```agda
emptyV : Vec ℕ 0
emptyV = []

upto3V : Vec ℕ 4
upto3V = 0 :: 1 :: 2 :: 3 :: []
```

## Векторы

То же самое для append, никаких изменений за исключением типа:
```agda
appendV : ∀ {A m n} → Vec A m → Vec A n → Vec A (m + n)
appendV [] ys = ys
appendV (x :: xs) ys = x :: appendV xs ys
```

## Получение головы списка - revisited

Используя Векторы мы можем реализовать функцию first:

```agda
firstV : ∀ {A n} → Vec A (1 + n) → A
firstV xs = ?
```

## Получение головы списка - revisited

Используя Векторы мы можем реализовать функцию first:

```agda
firstV : ∀ {A n} → Vec A (1 + n) → A
firstV (x :: xs) = ?
```

## Получение головы списка - revisited

Используя Векторы мы можем реализовать функцию first:

```agda
firstV : ∀ {A n} → Vec A (1 + n) → A
firstV (x :: _) = x
```

## Проблема - revisited

```agda
...
let queue = upto3 in
let min = firstV queue in
let x = min + 5 in
...
```

## Обобщение проблемы

Предыдущая проблема является частным случаем более общей проблемы: ошибка *выхода за границы*. Используя Векторы мы можем решить эту проблему в более общем случае.

## Обобщение проблемы

Предыдущая проблема является частным случаем более общей проблемы: ошибка *выхода за границы*. Используя Векторы мы можем решить эту проблему в более общем случае.

Мы хотим реализовать функцию:

```agda
_!_ : ∀ {A n} → Vec A n → ℕ< n → A
```

Как можно определить ℕ<?

## Тип ℕ<

Что такое число меньшее n? Можем ли мы дать индуктивное определение?

## Тип ℕ<

Что такое число меньшее n? Можем ли мы дать индуктивное определение?

```agda
data ℕ< : ℕ → Set where
  zero : ∀ {n} → ℕ< (1 + n)
  1+ : ∀ {n} → ℕ< n → ℕ< (1 + n)

three : ℕ< 7
three = 1+ (1+ (1+ zero))

three' : ℕ< 10
three' = 1+ (1+ (1+ zero))
```

## Lookup

Теперь мы можем определить оператор `_!_`:

```agda
_!_ : ∀ {A n} → Vec A n → ℕ< n → A
(x :: _) ! zero = x
(_ :: xs) ! (1+ m) = xs ! m
```
Теперь мы можем отлавливать ошибку выхода за границы во время компиляции:

## Lookup

Теперь мы можем определить оператор `_!_`:

```agda
_!_ : ∀ {A n} → Vec A n → ℕ< n → A
(x :: _) ! zero = x
(_ :: xs) ! (1+ m) = xs ! m
```
Теперь мы можем отлавливать ошибку выхода за границы во время компиляции:

```agda
one = upto3V ! (1+ zero)
out-of-bounds = upto3V ! (1+ (1+ (1+ (1+ zero))))
```

## Lookup

```agda
out-of-bounds = upto3V ! (1+ (1+ (1+ (1+ zero))))
```
> Type mismatch:
> expected: zero
>  actual: suc _n_103
> when checking that the expression 1+ (1+ (1+ (1+ zero)))
> has type ℕ< 4
